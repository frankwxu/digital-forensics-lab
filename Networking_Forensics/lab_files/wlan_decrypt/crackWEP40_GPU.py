# Generated By ChatGPT DGL
# Write Python code that generates all possible combinations of 8 characters, 
# with each character consisting of either a lowercase or uppercase English letter and 
# also has a function to check the XOR sum of the 0th, 3rd, 6th characters, 
# the XOR sum of the 1st, 4th, 7th characters, 
# and the XOR sum of the 2nd and 5th characters. 
# Also add function to check sha1 hash of the combination startwith 0xff7b948953ac
# Use Pytorch framework to use GPU

import torch
import string
import hashlib
import time
import itertools


def generate_combinations_test(device):
    ascii_codes = [ord(char) for char in "cgwpkexz"]
    return torch.tensor([ascii_codes], dtype=torch.uint8,  device=device)


def generate_combinations(device):
    characters = string.ascii_lowercase
    combinations = torch.tensor([list(map(ord, chars)) for chars in itertools.product(
        characters, repeat=8)], dtype=torch.uint8, device=device)
    return combinations


def check_xor_sum(combination):
    xor_sum_0_3_6 = combination[:, 0].int(
    ) ^ combination[:, 3].int() ^ combination[:, 6].int()
    xor_sum_1_4_7 = combination[:, 1].int(
    ) ^ combination[:, 4].int() ^ combination[:, 7].int()
    xor_sum_2_5 = combination[:, 2].int() ^ combination[:, 5].int()
    return (xor_sum_0_3_6 == 0x6b) & (xor_sum_1_4_7 == 0x76) & (xor_sum_2_5 == 0x12)          

def add_xy_and_check_sha1(valid_combinations, device):
    letters = 'abcdefghijklmnopqrstuvwxyz'
    xy_combinations = torch.tensor(
        [[ord(x), ord(y)] for x in letters for y in letters], dtype=torch.uint8, device=device)

    final_results = []
    for combination in valid_combinations:
        for xy in xy_combinations:
            new_combination = torch.cat((combination[:3], xy[0].unsqueeze(
                0), combination[3:6], xy[1].unsqueeze(0), combination[6:]), dim=0)
            sha1_hash = hashlib.sha1(
                new_combination.cpu().numpy().tobytes()).hexdigest()
            if sha1_hash.startswith('ff7b948953ac'):
                final_results.append(new_combination)
    return final_results

if torch.cuda.is_available():
    device = torch.device("cuda")
else:
    device = torch.device("cpu")


combinations = generate_combinations(device)
num_combinations = combinations.shape[0]
start_time = time.time()

valid_combinations = combinations[check_xor_sum(combinations)]
valid_combinations = add_xy_and_check_sha1(valid_combinations, device)
if len(valid_combinations) > 0:
    print(valid_combinations[0].char().cpu().numpy().tolist())
else:
    print("No valid combinations found")

end_time = time.time()
print("Processing took %.2f seconds for %d combinations" %
      (end_time - start_time, num_combinations))